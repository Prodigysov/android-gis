--- /home/jbaubort/Bureau/SIG Android/maps_lib_src/maps_lib/src/com/nutiteq/cache/MemoryCache.java	2010-11-23 10:44:36.000000000 +0100
+++ src/com/nutiteq/cache/MemoryCache.java	2010-11-30 16:05:02.000000000 +0100
@@ -1,7 +1,7 @@
 package com.nutiteq.cache;
 
-import java.util.Enumeration;
-import java.util.Hashtable;
+import java.util.Iterator;
+import java.util.LinkedHashMap;
 
 /**
  * <p>
@@ -15,21 +15,19 @@
  * </p>
  */
 public class MemoryCache implements Cache {
-  private final Hashtable cache;
+  private LinkedHashMap<String, CacheItem> cache;
   private final int maxSize;
-  private CacheItem mru;
-  private CacheItem lru;
   private int size;
 
   /**
    * Create a new MemoryCache instance.
    * 
    * @param cacheSize
-   *          cache size in bytes.
+   *            cache size in bytes.
    */
   public MemoryCache(final int cacheSize) {
     maxSize = cacheSize;
-    cache = new Hashtable();
+    cache = new LinkedHashMap<String, CacheItem>(40, 0.75f, true);
   }
 
   public void initialize() {
@@ -37,7 +35,10 @@
   }
 
   public void deinitialize() {
-
+    if (cache != null) {
+      cache.clear();
+    }
+    cache = null;
   }
 
   public byte[] get(final String cacheId) {
@@ -47,26 +48,6 @@
       return null;
     }
 
-    //make it the most recently used entry
-    if (mru != result) { //not already the MRU
-      if (lru == result) { // I'm the least recently used
-        lru = result.previous;
-      }
-
-      // Remove myself from the LRU list.
-      if (result.next != null) {
-        result.next.previous = result.previous;
-      }
-
-      result.previous.next = result.next;
-
-      // Add myself back in to the front.
-      mru.previous = result;
-      result.previous = null;
-      result.next = mru;
-      mru = result;
-    }
-
     return result.data;
   }
 
@@ -77,49 +58,38 @@
 
     final byte[] existing = get(cacheId);
     if (existing != null) {
-      // The key has already been used.  By calling get() we already promoted
-      // it to the MRU spot.  However, if the data has changed, we need to
-      // update it in the hash table.
-      //TODO jaanus : check also data content?
       if (existing.length != data.length) {
         final CacheItem i = (CacheItem) cache.get(cacheId);
         i.data = data;
+        size -= existing.length;
+        size += data.length;
       }
     } else {
       // cache miss
       final CacheItem item = new CacheItem();
       item.key = cacheId;
       item.data = data;
-      item.next = mru;
+      item.next = null;
       item.previous = null;
-
-      if (cache.size() == 0) {
-        // then cache is empty
-        lru = item;
-      } else {
-        mru.previous = item;
-      }
-
-      mru = item;
       cache.put(cacheId, item);
-
       size += data.length;
     }
 
-    while (size > maxSize) {
-      // Kick out the least recently used element.
-      cache.remove(lru.key);
-      size -= lru.data.length;
-
-      if (lru.previous != null) {
-        lru.previous.next = null;
-      }
+    // Clean old cache
+    if (size > maxSize) {
+       for (final Iterator<CacheItem> i = cache.values().iterator(); i.hasNext();) {
+         CacheItem c = (CacheItem) i.next();
+         size -= c.data.length;
+         cache.remove(c);
+       }
 
-      lru = lru.previous;
     }
   }
 
   public boolean contains(final String cacheKey) {
+    if (cache == null) {
+      return false;
+    }
     return cache.containsKey(cacheKey);
   }
 
@@ -131,23 +101,24 @@
     return contains(cacheKey);
   }
 
-  //TEST METHODS
+  // TEST METHODS
   protected int getCalculatedSize() {
     return size;
   }
 
-  protected int getActualElementsSize() {
-    final Enumeration e = cache.elements();
-    int result = 0;
-    while (e.hasMoreElements()) {
-      final CacheItem item = (CacheItem) e.nextElement();
-      result += item.data.length;
-    }
-
-    return result;
-  }
+  // protected int getActualElementsSize() {
+  // final Enumeration<CacheItem> e = cache.elements();
+  // int result = 0;
+  // while (e.hasMoreElements()) {
+  // final CacheItem item = (CacheItem) e.nextElement();
+  // result += item.data.length;
+  // }
+  //
+  // return result;
+  // }
 
   protected CacheItem getMRU() {
-    return mru;
+    return null;
+      // return mru;
   }
 }
